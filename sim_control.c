/******** DO NOT EDIT THIS FILE ********/
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <string.h>
#include "sim_control.h"
#include "joblog.h"

/* copy of BSD strnstr function - see end of file */
static char* bsd_strnstr(const char* s, const char* find, size_t slen);

static void print_status(simulation_t* sim, char* status) {
    printf("\n%s %d %s\n", sim->proc->name, sim->proc->id, status);
}

static void print_usage(char** argv) {
    printf( "usage: %s <jobs> [-i] [-sf <w.d>] [-ds <ms>] [-de <ms>]\n\
            [-w <min_crit> <max_crit> [<min_ncrit> <max_ncrit>]]\n", argv[0]);
            
    printf( "       jobs is the number of jobs to process >= 1\n"
            "       -i  = the init process sets up shared objects etc,\n"
            "             there should be one and only one init process\n"
            "       -sf = set the floating point skip factor: the multiplier\n"
            "             of number of jobs to tolerate queue empty skip\n"
            "       -ds = delay this process by ms before starting work\n"
            "       -de = delay this process by ms after finishing work\n"
            "       -w  = specify ranges for critical and non-critical work\n"
            "             as pairs of min and max values, defaults are:\n"
            "             (10, 100) and (10, 100) - non-critical work is the\n"
            "             same as critical work if not specified\n");
}

static proc_t* proc_init(int argc, char** argv, proctype_t type, 
    double* skip_factor) {    
    char name[MAX_NAME_SIZE];
    (void) snprintf(name, MAX_NAME_SIZE, "%s", argv[0]);
    int jobs = atoi(argv[1]);
    bool is_init = false;
    long delay_start = 0;
    long delay_exit = 0;
    
    work_ms_t crit_work = { MIN_WORK_DEFAULT, MAX_WORK_DEFAULT };
    work_ms_t noncrit_work = crit_work;
    
    if (argc >= 3) {
        int next_arg = 2;
        
        if (strncmp(argv[next_arg], "-i", 2) == 0) {
            next_arg++;
            is_init = true;
        }
        
        if (argc > next_arg && strncmp(argv[next_arg], "-sf", 3) == 0) {
            next_arg++;
            if ((argc - next_arg) >= 1) {
                *skip_factor = atof(argv[next_arg]);
                next_arg++;
            }
        }

        if (argc > next_arg && strncmp(argv[next_arg], "-ds", 3) == 0) {
            next_arg++;
            if ((argc - next_arg) >= 1) {
                delay_start = atol(argv[next_arg]);
                next_arg++;
            }
        }
                
        if (argc > next_arg && strncmp(argv[next_arg], "-de", 3) == 0) {
            next_arg++;
            if ((argc - next_arg) >= 1) {
                delay_exit = atol(argv[next_arg]);
                next_arg++;
            }
        }

        if (argc > next_arg && strncmp(argv[next_arg], "-w", 2) == 0) {
            next_arg++;
            if ((argc - next_arg) >= 2) {
                crit_work.min = atol(argv[next_arg]);
                next_arg++;
                crit_work.max = atol(argv[next_arg]);
                next_arg++;

                if ((argc - next_arg) == 2) {
                    noncrit_work.min = atol(argv[next_arg]);
                    next_arg++;
                    noncrit_work.max = atol(argv[next_arg]);
                } else {
                    noncrit_work.min = crit_work.min;
                    noncrit_work.max = crit_work.max;
                }
            }
        }
    }

    // seed random number generator
    time_t t;
    srandom((unsigned) time(&t));
    
    pid_t id = getpid();
    
    // normalise id if using peterson's solution - init proc is even id and 
    // reset consumers to be non-init
    if (bsd_strnstr(argv[0], "peterson", MAX_NAME_SIZE)) {
        id = is_init ? id + id % 2 : id + 1 - id % 2;
        
        if (bsd_strnstr(argv[0], "consumer", MAX_NAME_SIZE))
            is_init = false;
    }

    return proc_new(type, name, id, jobs, is_init, delay_start,
        delay_exit, crit_work, noncrit_work);
}

static void error_exit(int line, const char* err_msg) {
    char msg[80];
    (void) snprintf(msg, 80, "%s:%d: %s", __FILE__, line, err_msg);
    perror(msg);
    exit(EXIT_FAILURE);
}

void simulation_update(simulation_t* sim, job_t* job) {
    if (job) {
        joblog_write(sim->proc, job);
        sim->proc->jobs--;
        sim->skips = 0;
    } else {
        sim->skips++;
    }       

    printf(".");
    do_noncritical_work(sim->proc);     

    fflush(stdout);
}

simulation_t* simulation_setup(int argc, char** argv, proctype_t proc_type, 
    shobj_ctrl_t* queue_ctrl, shobj_ctrl_t* mutex_ctrl) {
    if (argc < 2) {
        print_usage(argv);
        exit(EXIT_FAILURE);
    }
    
    if (!queue_ctrl)
        error_exit(__LINE__, "NULL queue control");
        
    simulation_t* sim = (simulation_t*) malloc(sizeof(simulation_t));
    
    if (!sim) 
        error_exit(__LINE__, "could not create simulation");
        
    sim->queue = NULL;
    sim->queue_destructor = queue_ctrl->destructor;
    sim->mutex = NULL;
    sim->mutex_destructor = mutex_ctrl ? mutex_ctrl->destructor : NULL;
    
    double skip_factor = DEFAULT_SKIP_FACTOR;

    sim->proc = proc_init(argc, argv, proc_type, &skip_factor);
    
    if (sim->proc) {
        print_status(sim, "starting...");
        
        delay_ms(sim->proc->delay_start);

        sim->queue = queue_ctrl->constructor(sim->proc);
        if (!sim->queue) {
            simulation_delete(sim);
            error_exit(__LINE__, "could not create queue");
        }
        
        if (mutex_ctrl) {
            sim->mutex = mutex_ctrl->constructor(sim->proc);
            
            if (!sim->mutex) {
                simulation_delete(sim);
                error_exit(__LINE__, "could not create mutex");
            }            
        }
        
        if (joblog_init(sim->proc) == -1) {
            simulation_delete(sim);
            error_exit(__LINE__, "could not initialise job log");
        }
    } else {
        simulation_delete(sim);
        error_exit(__LINE__, "could not create proc descriptor");
    }

    sim->skips = 0;
    sim->skip_limit = (int) sim->proc->jobs * skip_factor;
    
    return sim; 
}

int simulation_teardown(simulation_t* sim) {
    static const char* stopmsg_fmt = "stopped with %d %s to do";

    delay_ms(sim->proc->delay_exit);
    
    char* job_summary;

    asprintf(&job_summary, stopmsg_fmt, sim->proc->jobs, 
            sim->proc->jobs == 1 ? "job" : "jobs");
    
    print_status(sim, job_summary);
    
    free(job_summary);
    simulation_delete(sim);
    
    return EXIT_SUCCESS;
}

void simulation_delete(simulation_t* sim) {
    if (sim->proc)
        proc_delete(sim->proc);
        
    if (sim->queue)
        sim->queue_destructor(sim->queue);
    
    if (sim->mutex)
        sim->mutex_destructor(sim->mutex);
        
    free(sim);
}


/****************************************************************************
 * Copy of BSD strnstr function which is missing on many linux distributions
 * (renamed bsd_strnstr to avoid name clashes)
 ****************************************************************************
 */
/*-
 * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Find the first occurrence of find in s, where the search is limited to the
 * first slen characters of s.
 */
static char* bsd_strnstr(const char* s, const char* find, size_t slen) {
    char c, sc;
    size_t len;

    if ((c = *find++) != '\0') {
        len = strlen(find);
        do {
            do {
                if (slen-- < 1 || (sc = *s++) == '\0')
                    return NULL;
            } while (sc != c);
            if (len > slen)
                return NULL;
		} while (strncmp(s, find, len) != 0);
		s--;
	}

    return (char*) s;
}

/****************************************************************************/


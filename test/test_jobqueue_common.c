/******** DO NOT EDIT THIS FILE ********/
#include "test_jobqueue_common.h"
#include <stdio.h>
#define SJOB_STR_SIZE 32


/* simple job queue definition and functions to verify ordering */
typedef struct simple_job {
    int pid;
    unsigned int id;
    unsigned int pri;
} sjob_t;

typedef struct sj_queue {
    int buf_size;
    int size;
    sjob_t buf[JOB_BUFFER_SIZE];
} sjq_t;

static void sjq_init(sjq_t* sjq) {
    sjq->size = 0; 
    sjq->buf_size = JOB_BUFFER_SIZE;
    for (int i = 0; i < sjq->buf_size; i++)
        sjq->buf[i].pid = -1;
}
    
static void sjq_nq(sjq_t* sjq, job_t* job) {
    if (sjq->size == sjq->buf_size || !job->priority) 
        return;

    int top = sjq->size;
    
    for (int i = 0; i < sjq->size; i++) {
        if (sjq->buf[i].pri <= job->priority) {
            top = i;
            break;
        }
    }
        
    for (int i = sjq->size - 1; i > top - 1; i--)
        sjq->buf[i + 1] = sjq->buf[i];

    sjq->buf[top].pid = job->pid;
    sjq->buf[top].id = job->id;
    sjq->buf[top].pri = job->priority; 
    
    sjq->size++;
    
    return;
} 
    
static sjob_t* sjq_dq(sjq_t* sjq, sjob_t* j) {
    if (!sjq->size || sjq->buf[sjq->size - 1].pid < 0  
        || !sjq->buf[sjq->size - 1].pri)
        return NULL;
        
    *j = sjq->buf[sjq->size - 1];
    
    sjq->buf[sjq->size - 1].pid = -1; // initialise
    
    sjq->size--;

    return j;
}

static sjob_t* sjq_peek(sjq_t* sjq, sjob_t* j) {
    if (!sjq->size || sjq->buf[sjq->size - 1].pid < 0  
        || !sjq->buf[sjq->size - 1].pri)
        return NULL;

    *j = sjq->buf[sjq->size - 1];
    
    return j;
}

static bool sj_job_equal(sjob_t* sj, job_t* job) {
    return sj->pid == job->pid && sj->id == job->id && sj->pri == job->priority;
}

/* utility functions */
static void set_job_2sj(job_t* job, sjob_t* sj) {
    set_job(job, sj->pid, sj->id, sj->pri);
}

/* shared utility functions */
void init_job(job_t* job) {
    set_job(job, 0, 0, 0);
}

void set_job(job_t* job, pid_t pid, unsigned int id, unsigned int priority) {
    job->pid = pid;
    job->id = id;
    job->priority = priority;
    
    (void) snprintf(job->label, MAX_NAME_SIZE, "%s", PAD_STRING);
}

bool jobs_initialised(job_t* jobs, int buf_size, int empty_slots) {
    job_t ij;
    init_job(&ij);
    int initialised = 0;
    
    for (int i = 0; i < buf_size; i++) {
        if (equal_jobs(&jobs[i], &ij))
            initialised++;
    }
    
    return initialised == empty_slots;
}

bool jobs_valid(job_t* jobs, int buf_size, int full_slots) {
    int valid = 0;
    
    for (int i = 0; i < buf_size; i++) {
        if (jobs[i].priority > 0) 
            valid++;
    }
    
    return valid == full_slots;
}

void assert_queue_initialised(pri_jobqueue_t* q) {
    assert_not_null(q);
    assert_int(q->size, ==, 0);
    assert_int(q->buf_size, ==, JOB_BUFFER_SIZE);
     
    assert_true(jobs_initialised(q->jobs, q->buf_size, q->buf_size));    
}

bool equal_jobs(job_t* j1, job_t* j2) {
    return j1->pid == j2->pid && j1->id == j2->id 
            && j1->priority == j2->priority
            && !strncmp(j1->label, j2->label, MAX_NAME_SIZE);
}

static bool is_init_job(job_t* j) {
    return !j->pid && !j->id && !j->priority 
            && !strncmp(j->label, PAD_STRING, MAX_NAME_SIZE);
}

static bool equal_and_distinct(job_t* j1, job_t* j2) {
    return j1 != j2 && j1->label != j2->label && equal_jobs(j1, j2);
}

static bool tq_is_full(test_jq_t* test_jq) {
    return !test_jq->q
           || (test_jq->qimpl->size == test_jq->qimpl->buf_size
                && jobs_valid(test_jq->qimpl->jobs, test_jq->qimpl->buf_size,
                        test_jq->qimpl->buf_size));
}

static bool tq_is_empty(test_jq_t* test_jq) {
    return !test_jq->q 
            || (!test_jq->qimpl->size 
                    && jobs_initialised(test_jq->qimpl->jobs,
                        test_jq->qimpl->buf_size, test_jq->qimpl->buf_size));
}

typedef enum genval_method { V_RAND, V_SAME, V_DECR, V_INCR } genval_method_t;

#define SAME_VAL 1

// think about a fifo list by priority
static unsigned int genvalue(genval_method_t method, unsigned int field) {
    switch (method) {
        case V_RAND:
            field = munit_rand_int_range(SAME_VAL, 20); 
            break;
        case V_SAME:
            field = SAME_VAL;
            break;
        case V_DECR:
            field--;
            break;
        case V_INCR:
            field++;
            break;
        default:
            field = 0;
    }
    
    return field;
}

static bool fill_queue(sjq_t* sjq, test_jq_t* test_jq, genval_method_t pid_gvm, 
    genval_method_t id_gvm, genval_method_t pri_gvm) {
    unsigned int priority = pri_gvm == V_DECR ? JOB_BUFFER_SIZE * 2: 0;
    
    int i = 0;
    
    for (i = 0; i < JOB_BUFFER_SIZE; i++) {
        job_t j;
        pid_t pid = genvalue(pid_gvm, i + 1);
        unsigned int id = genvalue(id_gvm, i);
        priority = genvalue(pri_gvm, priority);

        set_job(&j, pid, id, priority);
        test_jq->enqueue(test_jq->q, &j);
        sjq_nq(sjq, &j);
    }
    
    assert(tq_is_full(test_jq));
    assert(!tq_is_empty(test_jq));

    return i == test_jq->qimpl->buf_size 
            && sjq->size == test_jq->qimpl->buf_size;
}

static MunitResult test_jq_ndequeue_tofull(test_jq_t* test_jq, bool same_pid,
    bool same_id, int pri_method) {
    assert_true(jobs_initialised(test_jq->qimpl->jobs, test_jq->qimpl->buf_size,
        test_jq->qimpl->buf_size));
        
    sjq_t sjq;
    sjq_init(&sjq);
    assert_true(fill_queue(&sjq, test_jq, pri_method, same_pid, same_id));
    
    int i = 0;

    while (!tq_is_empty(test_jq)) {
        job_t param_j;
        job_t expected_j;
        sjob_t sj;
        assert_not_null(sjq_dq(&sjq, &sj));
        set_job_2sj(&expected_j, &sj);
        
        int prev_size = test_jq->qimpl->size;
        
        job_t* dq_j = test_jq->dequeue(test_jq->q, &param_j); 
        
        assert_int(test_jq->qimpl->size, ==, prev_size - 1);
        assert_true(jobs_initialised(test_jq->qimpl->jobs,
                    test_jq->qimpl->buf_size, 
                    test_jq->qimpl->buf_size - test_jq->qimpl->size));
        assert_true(jobs_valid(test_jq->qimpl->jobs, test_jq->qimpl->buf_size,
                        test_jq->qimpl->size));
    
        assert_false(is_init_job(dq_j)); 

        assert_true(equal_and_distinct(dq_j, &expected_j));
        assert_ptr_equal(dq_j, &param_j);
                
        i++;
    }
    
    assert_true(!tq_is_full(test_jq));
    assert_true(tq_is_empty(test_jq));
    
    return MUNIT_OK;
} 

/* tests */
MunitResult test_pjq_init(test_jq_t* test_jq) {
    pri_jobqueue_t* q = (pri_jobqueue_t*) malloc(sizeof(pri_jobqueue_t));
    
    pri_jobqueue_init(q);
    
    assert_queue_initialised(q);
    
    free(q);
    
    unsigned int priority = 0;
    
    for (int i = 0; i < JOB_BUFFER_SIZE; i++) {
        job_t j;
        priority = genvalue(V_SAME, priority);
        set_job(&j, i + 1, i, priority);
        test_jq->qimpl->jobs[i] = j;
        test_jq->qimpl->size++;
    }

    assert_false(tq_is_empty(test_jq));
    assert_true(tq_is_full(test_jq));

    pri_jobqueue_init((pri_jobqueue_t*) test_jq->q);
    assert_queue_initialised((pri_jobqueue_t*) test_jq->q);

    return MUNIT_OK;
}

MunitResult test_jq_ndequeue_randpri(test_jq_t* test_jq) {
    return test_jq_ndequeue_tofull(test_jq, V_INCR, V_INCR, V_RAND);
}

MunitResult test_jq_ndequeue_decpri(test_jq_t* test_jq) {
    return test_jq_ndequeue_tofull(test_jq, V_INCR, V_INCR, V_DECR);
}

MunitResult test_jq_ndequeue_incpri(test_jq_t* test_jq) {
    return test_jq_ndequeue_tofull(test_jq, V_INCR, V_INCR, V_DECR);
}

MunitResult test_jq_ndequeue_inout(test_jq_t* test_jq) {
    sjq_t sjq;
    sjq_init(&sjq);
    int ops = test_jq->qimpl->buf_size;
    ops += ops / 2;
    int i = 0;

    for (i = 0; i < ops; i++) {
        job_t param_j;
        job_t expected_j;
        sjob_t sj;
        set_job(&expected_j, i, i + 1, genvalue(V_RAND, 0));
        
        int prev_size = test_jq->qimpl->size;
        test_jq->enqueue(test_jq->q, &expected_j);
        sjq_nq(&sjq, &expected_j);
        
        assert_int(test_jq->qimpl->size, ==, prev_size + 1);
        
        job_t* dq_j = test_jq->dequeue(test_jq->q, &param_j);
        assert_not_null(sjq_dq(&sjq, &sj));
        
        assert_true(sj_job_equal(&sj, dq_j));
        assert_true(sj_job_equal(&sj, &expected_j));
        
        assert_int(test_jq->qimpl->size, ==, prev_size);
        assert_true(jobs_initialised(test_jq->qimpl->jobs,
            test_jq->qimpl->buf_size, 
            test_jq->qimpl->buf_size - test_jq->qimpl->size));
        assert_true(jobs_valid(test_jq->qimpl->jobs, test_jq->qimpl->buf_size,
                        test_jq->qimpl->size));
        
        assert_false(is_init_job(dq_j)); 

        assert_true(equal_and_distinct(dq_j, &expected_j));
        assert_ptr_equal(dq_j, &param_j);
    }
    
    assert_int(i, ==, ops);

    assert_true(!tq_is_full(test_jq));
    assert_true(tq_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_ndequeue_randinout(test_jq_t* test_jq) {
    sjq_t sjq;
    sjq_init(&sjq);
    int ops = test_jq->qimpl->buf_size * 2;
    int i = 0;
    int prev_size = test_jq->qimpl->size;
    
    for (i = 0; i < ops; i++) {
        
        for (int j = 0; j < munit_rand_int_range(0, 20); j++) {
            if (sjq.size != sjq.buf_size) {
                job_t job;
                set_job(&job, genvalue(V_RAND, 0), genvalue(V_RAND, 0), 
                        genvalue(V_RAND, 0));
                               
                test_jq->enqueue(test_jq->q, &job);
                sjq_nq(&sjq, &job);
                
                assert_int(test_jq->qimpl->size, ==, prev_size + 1);
                prev_size = test_jq->qimpl->size;

                assert_true(jobs_initialised(test_jq->qimpl->jobs,
                    test_jq->qimpl->buf_size, 
                    test_jq->qimpl->buf_size - test_jq->qimpl->size));
                assert_true(jobs_valid(test_jq->qimpl->jobs,
                    test_jq->qimpl->buf_size, test_jq->qimpl->size));
            }
        }
       
        for (int j = 0; j < munit_rand_int_range(0, 20); j++) {
            if (sjq.size) {
                job_t job;
                sjob_t sjob;
                
                job_t* dq_j = test_jq->dequeue(test_jq->q, &job);
                assert_not_null(sjq_dq(&sjq, &sjob));
                
                assert_true(sj_job_equal(&sjob, dq_j));
                assert_int(test_jq->qimpl->size, ==, prev_size - 1);
                prev_size = test_jq->qimpl->size;
                assert_true(jobs_initialised(test_jq->qimpl->jobs,
                    test_jq->qimpl->buf_size, 
                    test_jq->qimpl->buf_size - test_jq->qimpl->size));
                assert_true(jobs_valid(test_jq->qimpl->jobs,
                    test_jq->qimpl->buf_size, test_jq->qimpl->size));
        
                assert_false(is_init_job(dq_j)); 
            }
        }
    }
    
    assert_int(i, ==, ops);
    
    while (sjq.size) {
        job_t job;
        sjob_t sjob;
        
        job_t* dq_j = test_jq->dequeue(test_jq->q, &job);
        assert_not_null(sjq_dq(&sjq, &sjob));
        
        assert_true(sj_job_equal(&sjob, dq_j));
        assert_int(test_jq->qimpl->size, ==, prev_size - 1);
        prev_size = test_jq->qimpl->size;
        assert_true(jobs_initialised(test_jq->qimpl->jobs,
            test_jq->qimpl->buf_size, 
            test_jq->qimpl->buf_size - test_jq->qimpl->size));
        assert_true(jobs_valid(test_jq->qimpl->jobs,
            test_jq->qimpl->buf_size, test_jq->qimpl->size));

        assert_false(is_init_job(dq_j)); 
    }
    
    assert_true(!tq_is_full(test_jq));
    assert_true(tq_is_empty(test_jq));            
    
    return MUNIT_OK;
}

MunitResult test_jq_ndequeue_heap(test_jq_t* test_jq) {
    sjq_t sjq;
    sjq_init(&sjq);
    assert_true(fill_queue(&sjq, test_jq, V_INCR, V_INCR, V_RAND));
    
    int i = 0;
    
    while (!tq_is_empty(test_jq)) {
        job_t expected_j;
        sjob_t sj;
        assert_not_null(sjq_dq(&sjq, &sj));
        set_job_2sj(&expected_j, &sj);
        
        int prev_size = test_jq->qimpl->size;

        job_t* dq_j = test_jq->dequeue(test_jq->q, NULL);       
        
        assert_int(test_jq->qimpl->size, ==, prev_size - 1);
        assert_true(jobs_initialised(test_jq->qimpl->jobs,
            test_jq->qimpl->buf_size, 
            test_jq->qimpl->buf_size - test_jq->qimpl->size));
        assert_true(jobs_valid(test_jq->qimpl->jobs, test_jq->qimpl->buf_size,
                        test_jq->qimpl->size));

        assert_false(is_init_job(dq_j)); 

        assert_true(equal_and_distinct(dq_j, &expected_j));
        
        free(dq_j); // fail if not dyamically allocated
        i++;
    }
    
    assert_true(!tq_is_full(test_jq));
    assert_true(tq_is_empty(test_jq));

    return MUNIT_OK;
}

MunitResult test_jq_ndequeue_samepid(test_jq_t* test_jq) {
    return test_jq_ndequeue_tofull(test_jq, V_SAME, V_INCR, V_RAND);
}

MunitResult test_jq_ndequeue_sameid(test_jq_t* test_jq) {
    return test_jq_ndequeue_tofull(test_jq, V_INCR, V_SAME, V_RAND);
}

MunitResult test_jq_ndequeue_samepri(test_jq_t* test_jq) {
    return test_jq_ndequeue_tofull(test_jq, V_INCR, V_INCR, V_SAME);
}

MunitResult test_jq_ndequeue_samepidid(test_jq_t* test_jq) {
    return test_jq_ndequeue_tofull(test_jq, V_SAME, V_SAME, V_RAND);
}

MunitResult test_jq_ndequeue_samepidpri(test_jq_t* test_jq) {
    return test_jq_ndequeue_tofull(test_jq, V_SAME, V_INCR, V_SAME);
}

MunitResult test_jq_ndequeue_sameidpri(test_jq_t* test_jq) {
    return test_jq_ndequeue_tofull(test_jq, V_INCR, V_SAME, V_SAME);
}

MunitResult test_jq_ndequeue_sameall(test_jq_t* test_jq) {
    return test_jq_ndequeue_tofull(test_jq, V_SAME, V_SAME, V_SAME);
}

MunitResult test_jq_ndequeue_fifo(test_jq_t* test_jq) {
    for (int i = 0; i < JOB_BUFFER_SIZE; i++) {
        job_t job;
        set_job(&job, 1, i + 1, 1);
        
        test_jq->enqueue(test_jq->q, &job);
    }
    
    assert_int(test_jq->qimpl->size, ==, JOB_BUFFER_SIZE);
    
    for (int i = 0; i < JOB_BUFFER_SIZE; i++) {
        job_t job;
        
        job_t* dq_job = test_jq->dequeue(test_jq->q, &job);
        
        assert_int(dq_job->id, ==,  i + 1);
        assert_int(dq_job->pid, ==, 1);
        assert_int(dq_job->priority, ==, 1);
    }
    
    assert_int(test_jq->qimpl->size, ==, 0);
     
    for (int i = 0; i < JOB_BUFFER_SIZE; i++) {
        job_t job;
        set_job(&job, i + 1, 1, 1);
        
        test_jq->enqueue(test_jq->q, &job);
    }
    
    assert_int(test_jq->qimpl->size, ==, JOB_BUFFER_SIZE);
    
    for (int i = 0; i < JOB_BUFFER_SIZE; i++) {
        job_t job;
        
        job_t* dq_job = test_jq->dequeue(test_jq->q, &job);
        
        assert_int(dq_job->pid, ==,  i + 1);
        assert_int(dq_job->id, ==, 1);
        assert_int(dq_job->priority, ==, 1);
    }
    
    assert_int(test_jq->qimpl->size, ==, 0);
     
    return MUNIT_OK;
}



MunitResult test_jq_dequeue_empty(test_jq_t* test_jq) {
    // tests dequeuing from empty queue does not change queue state
    int buf_size = test_jq->qimpl->buf_size;
    int test_dequeues = buf_size + (buf_size / 3);
    
    job_t j;
    for (int i = 0; i < test_dequeues; i++) {
        int prev_size = test_jq->qimpl->size;
        assert_null(test_jq->dequeue(test_jq->q, &j));
        assert_int(test_jq->qimpl->size, ==, prev_size);
    }
    
    assert_true(tq_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_dequeue_null(test_jq_t* test_jq) {
    job_t job;
    assert_null(test_jq->dequeue(NULL, &job));

    return MUNIT_OK;
}

MunitResult test_jq_enqueue_full(test_jq_t* test_jq) {
    sjq_t sjq;
    sjq_init(&sjq);
    assert_true(fill_queue(&sjq, test_jq, V_INCR, V_INCR, V_RAND));
    
    job_t job;
    
    set_job(&job, 1, 1, 1);
    
    int prev_size = test_jq->qimpl->size;
    test_jq->enqueue(test_jq->q, &job);
    assert_int(test_jq->qimpl->size, ==, prev_size);
    assert_true(tq_is_full(test_jq));

    return MUNIT_OK;
}

MunitResult test_jq_enqueue_null(test_jq_t* test_jq) {
    job_t job;
    
    // the following should just not cause errors
    test_jq->enqueue(NULL, &job);

    test_jq->enqueue(test_jq->q, NULL);
    
    assert_queue_initialised(test_jq->qimpl);

    return MUNIT_OK;
}

MunitResult test_jq_enqueue_zeropri(test_jq_t* test_jq) {
    job_t job;
    
    set_job(&job, 1, 1, 0);
    
    int prev_size = test_jq->qimpl->size;
    test_jq->enqueue(test_jq->q, &job);
    assert_int(test_jq->qimpl->size, ==, prev_size);
    assert_true(!tq_is_full(test_jq));
    assert_true(tq_is_empty(test_jq));

    return MUNIT_OK;
}

MunitResult test_jq_enqueue_badjob(test_jq_t* test_jq) {
    job_t job;
    
    set_job(&job, 1, 1, 1);
    
    job.label[MAX_NAME_SIZE - 1] = '*';

    int prev_size = test_jq->qimpl->size;
    
    test_jq->enqueue(test_jq->q, &job);
    
    assert_int(test_jq->qimpl->size, ==, prev_size);

    return MUNIT_OK;
}

MunitResult test_jq_is_empty(test_jq_t* test_jq) {
    assert_true(test_jq->is_empty(test_jq->q));
    assert_true(tq_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_is_empty_notempty(test_jq_t* test_jq) {
    for (int i = 0; i < test_jq->qimpl->buf_size; i++) {
        job_t j;
        set_job(&j, i, i, i+1);
        test_jq->qimpl->jobs[i] = j;
        test_jq->qimpl->size += 1;
        assert_false(test_jq->is_empty(test_jq->q));
        assert_true(!tq_is_empty(test_jq));
    }
        
    return MUNIT_OK;
}

MunitResult test_jq_is_empty_nqnotempty(test_jq_t* test_jq) {
    for (int i = 0; i < test_jq->qimpl->buf_size; i++) {
        job_t j;
        set_job(&j, i, i, i+1);
        test_jq->enqueue(test_jq->q, &j);
        assert_false(test_jq->is_empty(test_jq->q));
        assert_true(!tq_is_empty(test_jq));
    }
        
    return MUNIT_OK;
}

MunitResult test_jq_is_empty_null(test_jq_t* test_jq) {
    assert_true(test_jq->is_empty(NULL));
    
    return MUNIT_OK;
}

MunitResult test_jq_is_full_empty(test_jq_t* test_jq) {
    assert_false(test_jq->is_full(test_jq->q));
    assert_true(!tq_is_full(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_is_full_filling(test_jq_t* test_jq) {
    for (int i = 0; i < test_jq->qimpl->buf_size; i++) {
        job_t j;
        set_job(&j, i, i + 1, i + 1);
        test_jq->qimpl->jobs[i] = j;
        test_jq->qimpl->size += 1;
        if (i < test_jq->qimpl->buf_size - 1) {
            assert_false(test_jq->is_full(test_jq->q));
            assert_true(!tq_is_full(test_jq));
        }
    }
    
    assert_true(test_jq->is_full(test_jq->q));
    
    return MUNIT_OK;
}

MunitResult test_jq_is_full_nqfilling(test_jq_t* test_jq) {
    for (int i = 0; i < test_jq->qimpl->buf_size; i++) {
        job_t j;
        set_job(&j, i, i + 1, i + 1);
        test_jq->enqueue(test_jq->q, &j);
        if (i < test_jq->qimpl->buf_size - 1) {
            assert_false(test_jq->is_full(test_jq->q));
            assert_true(!tq_is_full(test_jq));
        }
    }
    
    assert_true(test_jq->is_full(test_jq->q));
    assert_true(tq_is_full(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_is_full_null(test_jq_t* test_jq) {
    assert_true(test_jq->is_full(NULL));
    
    return MUNIT_OK;
}

MunitResult test_jq_peek_full(test_jq_t* test_jq) {
    sjq_t sjq;
    sjq_init(&sjq);
    assert_true(fill_queue(&sjq, test_jq, V_INCR, V_INCR, V_RAND));
    
    int i = 0;

    while (!tq_is_empty(test_jq)) {
        job_t param_j;
        job_t expected_j;
        sjob_t sj;
        assert_not_null(sjq_peek(&sjq, &sj));
        set_job_2sj(&expected_j, &sj);
        
        int prev_size = test_jq->qimpl->size;
        
        job_t* peekj = test_jq->peek(test_jq->q, &param_j); 
        
        assert_int(test_jq->qimpl->size, ==, prev_size);
        assert_true(jobs_initialised(test_jq->qimpl->jobs,
            test_jq->qimpl->buf_size, 
            test_jq->qimpl->buf_size - prev_size));
        assert_true(jobs_valid(test_jq->qimpl->jobs, test_jq->qimpl->buf_size,     
            prev_size));
        
        assert_false(is_init_job(peekj)); 

        assert_true(equal_and_distinct(peekj, &expected_j));
        assert_ptr_equal(peekj, &param_j);
        
        job_t* dqj = test_jq->dequeue(test_jq->q, &param_j);
        
        assert_true(equal_and_distinct(dqj, &expected_j));
        assert_ptr_equal(dqj, &param_j);
        
        assert_int(test_jq->qimpl->size, ==, prev_size - 1);
        assert_true(jobs_initialised(test_jq->qimpl->jobs,
            test_jq->qimpl->buf_size, 
            test_jq->qimpl->buf_size - test_jq->qimpl->size));
        assert_true(jobs_valid(test_jq->qimpl->jobs, test_jq->qimpl->buf_size, 
            test_jq->qimpl->size));
       
        assert_not_null(sjq_dq(&sjq, &sj));
        assert_true(sj_job_equal(&sj, dqj));
        i++;
    }
    
    assert_true(!tq_is_full(test_jq));
    assert_true(tq_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_peek_empty(test_jq_t* test_jq) {
    int buf_size = test_jq->qimpl->buf_size;
    int test_peeks = buf_size + (buf_size / 3);
    
    job_t j;
    for (int i = 0; i < test_peeks; i++) {
        int prev_size = test_jq->qimpl->size;
        assert_null(test_jq->peek(test_jq->q, &j));
        assert_int(test_jq->qimpl->size, ==, prev_size);
        assert_int(test_jq->qimpl->size, ==, 0);
    }
    
    assert_true(tq_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_peek_heap(test_jq_t* test_jq) {
    sjq_t sjq;
    sjq_init(&sjq);
    assert_true(fill_queue(&sjq, test_jq, V_INCR, V_INCR, V_RAND));
    
    int i = 0;

    while (!tq_is_empty(test_jq)) {
        job_t param_j;
        job_t expected_j;
        sjob_t sj;
        assert_not_null(sjq_peek(&sjq, &sj));
        set_job_2sj(&expected_j, &sj);
        
        int prev_size = test_jq->qimpl->size;
        
        job_t* peekj = test_jq->peek(test_jq->q, NULL); 
        
        assert_int(test_jq->qimpl->size, ==, prev_size);
        assert_true(jobs_initialised(test_jq->qimpl->jobs, 
            test_jq->qimpl->buf_size, test_jq->qimpl->buf_size - prev_size));
        assert_true(jobs_valid(test_jq->qimpl->jobs, 
            test_jq->qimpl->buf_size, prev_size));
        
        assert_false(is_init_job(peekj)); 

        assert_not_null(peekj);
        assert_true(equal_and_distinct(peekj, &expected_j));
        assert_ptr_not_equal(peekj, &param_j);
        
        free(peekj);
        
        job_t* dqj = test_jq->dequeue(test_jq->q, &param_j);
        
        assert_true(equal_and_distinct(dqj, &expected_j));
        assert_ptr_equal(dqj, &param_j);
        
        assert_int(test_jq->qimpl->size, ==, prev_size - 1);
        assert_true(jobs_initialised(test_jq->qimpl->jobs, 
            test_jq->qimpl->buf_size, 
            test_jq->qimpl->buf_size - test_jq->qimpl->size));
        assert_true(jobs_valid(test_jq->qimpl->jobs, test_jq->qimpl->buf_size, 
            test_jq->qimpl->size));
       
        assert_not_null(sjq_dq(&sjq, &sj));
        assert_true(sj_job_equal(&sj, dqj));
        i++;
    }
    
    assert_true(!tq_is_full(test_jq));
    assert_true(tq_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_peek_null(test_jq_t* test_jq) {
    job_t job;
    assert_null(test_jq->dequeue(NULL, &job));

    return MUNIT_OK;
}

MunitResult test_jq_size_empty(test_jq_t* test_jq) {
    assert_int(test_jq->size(test_jq->q), ==, 0);
    assert_int(test_jq->qimpl->size, ==, 0);

    return MUNIT_OK;
}

MunitResult test_jq_size_filling(test_jq_t* test_jq) {
    for (int i = 0; i < test_jq->qimpl->buf_size; i++) {
        job_t j;
        set_job(&j, i, i + 1, i + 1);
        test_jq->qimpl->size += 1;
        test_jq->qimpl->jobs[i] = j;
        assert_int(test_jq->size(test_jq->q), ==, i + 1);
    }
    
    assert_int(test_jq->size(test_jq->q), ==, test_jq->qimpl->buf_size);
    assert_true(tq_is_full(test_jq));

    return MUNIT_OK;
}

MunitResult test_jq_size_nqfilling(test_jq_t* test_jq) {
    for (int i = 0; i < test_jq->qimpl->buf_size; i++) {
        job_t j;
        set_job(&j, i, i + 1, i + 1);
        test_jq->enqueue(test_jq->q, &j);
        
        assert_int(test_jq->size(test_jq->q), ==, i + 1);
        assert_int(test_jq->qimpl->size, ==, i + 1);
    }
    
    assert_int(test_jq->size(test_jq->q), ==, test_jq->qimpl->buf_size);
    assert_int(test_jq->size(test_jq->q), ==, test_jq->qimpl->buf_size);
    assert_true(tq_is_full(test_jq));

    return MUNIT_OK;
}

MunitResult test_jq_size_null(test_jq_t* test_jq) {
    assert_int(test_jq->size(NULL), ==, 0);

    return MUNIT_OK;
}

MunitResult test_jq_space_empty(test_jq_t* test_jq) {
    assert_int(test_jq->space(test_jq->q), ==, test_jq->qimpl->buf_size);

    return MUNIT_OK;
}

MunitResult test_jq_space_filling(test_jq_t* test_jq) {
    for (int i = 0; i < test_jq->qimpl->buf_size; i++) {
        job_t j;
        set_job(&j, i, i + 1, i + 1);
        test_jq->qimpl->size += 1;
        test_jq->qimpl->jobs[i] = j;
        assert_int(test_jq->space(test_jq->q), ==, 
                    test_jq->qimpl->buf_size - i - 1);
    }
    
    assert_int(test_jq->space(test_jq->q), ==, 0);
    assert_true(tq_is_full(test_jq));

    return MUNIT_OK;
}

MunitResult test_jq_space_nqfilling(test_jq_t* test_jq) {
    for (int i = 0; i < test_jq->qimpl->buf_size; i++) {
        job_t j;
        set_job(&j, i, i + 1, i + 1);
        test_jq->enqueue(test_jq->q, &j);
        
        assert_int(test_jq->space(test_jq->q), ==, 
                    test_jq->qimpl->buf_size - i - 1);
    }
    
    assert_int(test_jq->space(test_jq->q), ==, 0);
    assert_true(tq_is_full(test_jq));

    return MUNIT_OK;
}

MunitResult test_jq_space_null(test_jq_t* test_jq) {
    assert_int(test_jq->space(NULL), ==, 0);

    return MUNIT_OK;
}


/******** DO NOT EDIT THIS FILE ********/
#include <errno.h>
#include <stdio.h>
#include <sys/mman.h>
#include "../shobject_name.h"
#include "../mutex_peterson.h"
#include "test_mutex_peterson.h"
#include "procs4tests.h"

mutex_t* _mutex_new(proc_t* proc) {
    return ipc_new(proc, "mux_peters", sizeof(mutex_peterson_t));
}

int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

void* test_setup(const MunitParameter params[], void* user_data) {
    return new_test_procs();
}

void test_tear_down(void* fixture) {
    delete_test_procs((test_procs_t*) fixture);
}

static void init_mutex(mutex_t* m) {
    mutex_peterson_t* mp = (mutex_peterson_t*) m->addr;
    mp->turn = 0;
    mp->interested[0] = 0;
    mp->interested[1] = 0;    
}

static mutex_t* assert_mutex_new(proc_t* p) {
    mutex_t* m = mutex_new(p);
    
    char* mux_name;
    char* user = getenv("USER");
    if (!user) user = "anon";
    
    asprintf(&mux_name, SHOBJ_NAME_FMT, user, "mux_peters");
    
    assert_not_null(m);
    assert_string_equal(m->name, mux_name);
    
    free(mux_name);
    assert_not_null(m->addr);
    mutex_peterson_t* mp = (mutex_peterson_t*) m->addr;
    assert_int(mp->turn, ==, 0);
    assert_int(mp->interested[0], ==, 0);
    assert_int(mp->interested[1], ==, 0);

    return m;
}

static mutex_t* assert_mutex_enter(mutex_t* m) {
    mutex_peterson_t* mp = (mutex_peterson_t*) m->addr;

    mutex_enter(m);
    
    assert_int(mp->turn, ==, m->proc->id);
    assert_int(mp->interested[m->proc->id % 2], ==, 1);
    assert_int(mp->interested[1 - (m->proc->id % 2)], ==, 0);
    
    init_mutex(m);
    
    return m;
}

static void assert_tp_mutex_enter(test_procs_t* p) {
    mutex_t* min = _mutex_new(p->pin);
    mutex_t* mni = _mutex_new(p->pni);
    
    assert_mutex_enter(min);
    assert_mutex_enter(mni);
    
    ipc_delete(mni);
    ipc_delete(min);
}

static mutex_t* assert_mutex_leave(mutex_t* m) {
    mutex_peterson_t* mp = (mutex_peterson_t*) m->addr;
    
    int turn = mp->turn;
    
    mp->interested[m->proc->id % 2] = 1;

    mutex_leave(m);
    
    assert_int(mp->turn, ==, turn);
    assert_int(mp->interested[m->proc->id % 2], ==, 0);
    
    init_mutex(m);

    return m;
}

static void assert_tp_mutex_leave(test_procs_t* p) {
    mutex_t* min = _mutex_new(p->pin);
    mutex_t* mni = _mutex_new(p->pni);
    
    assert_mutex_leave(min);
    assert_mutex_leave(mni);
    
    ipc_delete(mni);
    ipc_delete(min);
}

static void assert_tp_mutex_new(test_procs_t* p) {
    mutex_t* min = assert_mutex_new(p->pin);
    mutex_t* mni = assert_mutex_new(p->pni);
    
    ipc_delete(mni);
    ipc_delete(min);
}
   
MunitResult test_mutex_new(const MunitParameter params[], 
    void* fixture) {
    test_procs_t* p = fixture;
    
    assert_tp_mutex_new(p);
    
    p->pin->id = 98;
    p->pin->id = 99;
    
    assert_tp_mutex_new(p);

    return MUNIT_OK;
}

MunitResult test_mutex_new_null(const MunitParameter params[], 
    void* fixture) {
    errno = 0;
    assert_null(mutex_new(NULL));
    assert_int(errno, ==, EINVAL);
    
    errno = 0;
        
    return MUNIT_OK;
}


MunitResult test_mutex_enter_01(const MunitParameter params[], 
    void* fixture) {
    test_procs_t* p = fixture;
    
    assert_tp_mutex_enter(p);
    
    return MUNIT_OK;
}
    
MunitResult test_mutex_enter_02(const MunitParameter params[], 
    void* fixture) {
    test_procs_t* p = fixture;
    
    p->pin->id = 98;
    p->pni->id = 99;
    
    assert_tp_mutex_enter(p);
    
    return MUNIT_OK;
}

MunitResult test_mutex_enter_null(const MunitParameter params[], 
    void* fixture) {
    mutex_enter(NULL); // should just succeed
    
    return MUNIT_OK;
}

MunitResult test_mutex_leave_01(const MunitParameter params[], 
    void* fixture) {
    test_procs_t* p = fixture;
    
    assert_tp_mutex_leave(p);
        
    return MUNIT_OK;
}

MunitResult test_mutex_leave_02(const MunitParameter params[], 
    void* fixture) {
    test_procs_t* p = fixture;
    
    p->pin->id = 98;
    p->pni->id = 99;
    
    assert_tp_mutex_leave(p);
    
    return MUNIT_OK;
}

MunitResult test_mutex_leave_null(const MunitParameter params[], 
    void* fixture) {
    mutex_leave(NULL); // should just succeed
    
    return MUNIT_OK;
}

MunitResult test_mutex_delete(const MunitParameter params[], 
    void* fixture) {
    test_procs_t* p = fixture;
    
    mutex_t* mux = _mutex_new(p->pin);

    char* mname = mux->name;
    
    /* the following should just not cause errors */
    mutex_delete(mux);
    
    /* make sure that unlink shared memory in case mutex_delete doesn't */
    shm_unlink(mname);

    /* check NULL OK */    
    mutex_delete(NULL);

    return MUNIT_OK;
}

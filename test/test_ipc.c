/******** DO NOT EDIT THIS FILE ********/
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <errno.h>
#include "test_ipc.h"
#include "../ipc.h"
#include "procs4tests.h"

int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

struct pdata {
    int value;
    int turn;
    int interested[2];
};

void enter(ipc_t* ipc, int id) {
    struct pdata* pd = (struct pdata*) ipc->addr;
    int other_id = 1 - id;
    pd->interested[id] = 1;
    pd->turn = id;
    
    while (pd->turn == id && pd->interested[other_id]) ;
}

void leave(ipc_t* ipc, int id) {
    struct pdata* pd = (struct pdata*) ipc->addr;
    pd->interested[id] = 0;
}

MunitResult test_ipc_err(const MunitParameter params[], void* fixture) {
    errno = 0;
    ipc_t* ipc = ipc_new(NULL, "test_ipc", 1);
    assert_null(ipc);
    assert_int(errno, ==, EINVAL);
    
    errno = 0;
    proc_t* cp = new_init_proc();
    ipc = ipc_new(cp, "test_ipc", 0);
    assert_null(ipc);
    assert_int(errno, ==, EINVAL);
    proc_delete(cp);
    
    errno = 0;
    ipc_delete(NULL);
    assert_int(errno, ==, 0);
    
    errno = 0;
    
    return MUNIT_OK;
}

MunitResult test_ipc(const MunitParameter params[], void* fixture) {   
    pid_t pid = fork();
    
    if (pid < -1)
        return MUNIT_FAIL;
    
    if (pid == 0) {
        // in child
        proc_t* cp = new_init_proc();
        ipc_t* ipc = ipc_new(cp, "test_ipc", sizeof(struct pdata));

        assert_not_null(ipc);
        
        char* c = (char*) ipc->addr;
        for (int i = 0; i < sizeof(struct pdata); i++)
            assert_char(c[i], ==, 0);
        
        struct pdata* c_pd = (struct pdata*) ipc->addr;
        
        int j = 0;
        // child waits for j to change
        while (j < 5) {
            munit_logf(MUNIT_LOG_DEBUG, 
                "Waiting to access c_pd->value and change j in child (%d)\n",   
                    j);
            enter(ipc, 0);
            j = c_pd->value;
            leave(ipc, 0);
            munit_logf(MUNIT_LOG_DEBUG, "j read in child (%d)\n", j);
       }
         
        assert_int(j, ==, 5);
        
        ipc_delete(ipc);
        
        proc_delete(cp);
        
        exit(j+1);
    } else {
        // in parent
        int child_stat;

        proc_t* pp = new_noninit_proc();

        ipc_t* ipc = ipc_new(pp, "test_ipc", sizeof(struct pdata));
            
        assert_not_null(ipc);

        struct pdata* p_pd = (struct pdata*) ipc->addr;
 
        int i = 0;
        while (i < 5) {
            enter(ipc, 1);
            munit_logf(MUNIT_LOG_DEBUG, 
                "Incrementing p_pd->value in parent (%d)...\n", p_pd->value);
            p_pd->value++;
            munit_logf(MUNIT_LOG_DEBUG, 
                "p_pd->value incremented in parent (%d)...\n", p_pd->value);
            leave(ipc, 1);
            i++;
        } 
        
        // wait for child to exit with value of i
        waitpid(pid, &child_stat, 0);
        ipc_delete(ipc);
        proc_delete(pp);
        assert_int(WEXITSTATUS(child_stat), ==, i + 1);
    }
    
    return MUNIT_OK;
}   
    
    

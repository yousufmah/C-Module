"""
DO NOT EDIT THIS FILE
This is a Python script for analysing logs after a simulation run.
Type:
    python3 analyselogs.py
for usage.
"""


import sys
import os

cons_t = 'cons'
prod_t = 'prod'
proc_names = { cons_t: 'consumer', prod_t: 'producer' }
          
""" log format: pid:%07d,id:%05u,pri:%05u,label:%31s   """
class Job:
    log_entry_len = 68
    log_field_count = 4
    pid_len = 7
    id_len = 5
    pri_len = 5
    label_len = 31
    
    @classmethod
    def from_log(cls, log_entry):
        corrupt = len(log_entry) != Job.log_entry_len
        pid = 0
        id = 0
        label = ''
                    
        fields = log_entry.split(',')
        
        if len(fields) == Job.log_field_count:
            try:
                pid_str = fields[0].split(':')[1]
                corrupt = corrupt or len(pid_str) != Job.pid_len
                pid_str = pid_str.lstrip('0')
                pid = int(pid_str) if pid_str else 0
            except Exception:
                pid = 0
            
            try:
                id_str = fields[1].split(':')[1]
                corrupt = corrupt or len(id_str) != Job.id_len
                id_str = id_str.lstrip('0')
                id = int(id_str) if id_str else 0
            except Exception:
                id = 0
                
            try:
                pri_str = fields[2].split(':')[1]
                corrupt = corrupt or len(pri_str) != Job.pri_len
                pri_str = pri_str.lstrip('0')
                priority = int(pri_str) if pri_str else 0
            except Exception:
                priority = 0
                
            try: 
                label = fields[3].split(':')[1]
            except Exception:
                label = ''

        return cls(pid, id, priority, label, corrupt, log_entry)
        
    def __init__(self, pid, id, priority, label, corrupt = False, 
        log_entry = ''):
        self._pid = pid
        self._id = id
        self._priority = priority
        self._label = label
        self._corrupt = corrupt or pid < 1 or id < 1 or priority < 1 \
                            or len(label) != Job.label_len
        self.log_entry = log_entry
        
    @property
    def pid(self):
        return self._pid
    
    @property
    def id(self):
        return self._id
    
    @property
    def priority(self):
        return self._priority
    
    @property
    def label(self):
        return self._label
        
    @property
    def corrupt(self):
        return self._corrupt
        
    def to_log(self):
        if not self.log_entry:
            self.log_entry = 'pid:{:07},id:{:05},pri:{:05},label:{:.31}'.format(
                            self.pid, self.id, self.priority, self.label)
        return self.log_entry

    def __str__(self):
        return '{:07}:{:05}:{:05}:{}'.format(self.pid, self.id, 
            self.priority, self.label)
    
    def __repr__(self):
        return 'Job({!r}, {!r}, {!r}, {!r})'.format(self.pid, self.id,
            self.priority, self.label)
        
    def __eq__(self, other):
        return isinstance(other, Job) and self.pid == other.pid \
                and self.id == other.id and self.priority == self.priority \
                and self.label == other.label
    
    def __hash__(self):
        return hash((self.pid, self.id, self.priority, self.label))

"""
The return value is a dictionary/map of dictionaries of the following form:

{ proctype: 
    { procid: [jobs] },
}

where jobs is a list of jobs, each job converted from a log line

"""
def read_logs(lognames):
    logs = {}
    for logname in lognames:
        with open(logname) as l:
            entries = l.read().splitlines()

        jobs = [Job.from_log(e) for e in entries]

        procname = os.path.basename(logname).split('_')
    
        proctype = procname[1][0:4]
        procid = int(procname[1][4:11].lstrip('0'))

        if proctype in logs:
            logs[proctype][procid] = jobs
        else:
            logs[proctype] = {procid: jobs}

    return logs
            
"""
The return value is a tuple that is a boolean indicator for whether violations
where detected (there are corrupt entries in any of the logs for the given 
proc type) and dictionary of procid key to set of corrupt entries. E.g. for 
keys pid1, pid2, pid3:

(violation_detected, 
    {   pid1: pid1_corrupt_entries,
        pid2: pid2_corrupt_entries
        pid3: pid3_corrupt_entries
    }
)
"""
def get_corruptions(logs, type):
    violation = False
    corruptions = {}
    
    if type not in logs:
        return (violation, corruptions)
    
    for k in logs[type].keys():
        corruptions[k] = [job for job in logs[type][k] if job.corrupt]

        violation = violation or bool(corruptions[k])
    
    return (violation, corruptions)

"""
The return value is a tuple that is a boolean indicator for whether 
violations are detected (there is at least one non-empty set of pairwise 
intersections) plus a list of tuples of the pairwise intersections for each combination of keys, e.g. for keys pid1, pid2, pid3:

(violation_detected, 
    [
        (pid1, pid2, set_of_pid1pid2_intersections), 
        (pid1, pid3, set_of_pid1pid3_intersections), 
        (pid2, pid3, set_of_pid2pid3_intersections),
    ]
)

If set of all members of intersections is needed do:
set([e for list_of_inter in [it[2] for it in inter] for e in list_of_inter])
"""
def get_intersections(logs, type):
    violation = False
    inter = []
    
    if type not in logs:
        return (violation, inter)
    
    keys = list(logs[type].keys())

    for i in range(len(keys)):
        j = i + 1
        while j <= len(keys) - 1:
            inter_set = set(logs[type][keys[i]]).intersection(
                                                    set(logs[type][keys[j]]))
            inter.append((keys[i], keys[j], inter_set))
            violation = violation or bool(inter_set)
            j = j + 1

    return (violation, inter)

"""
The return value is the set of all log entries for the given proctype.
"""
def get_union(logs, type):
    all_entries = []
    
    if type not in logs:
        return set()

    for l in logs[type].values():
        all_entries.extend(l)
    
    return set(all_entries)
    
"""
The return value is a tuple that is a boolean indicator for whether violations
where detected (there are duplicate entries any of the logs for the given 
proc type) and dictionary of procid key to set of duplicates. E.g. for 
keys pid1, pid2, pid3:

(violation_detected, 
    {   pid1: set_of_pid1_duplicates,
        pid2: set_of_pid2_duplicates
        pid3: set_of_pid3_duplicates
    }
)
"""
def get_duplicates(logs, type):
    violation = False
    all_dups = {}
    
    if type not in logs:
        return (violation, all_dups)
    
    for k in logs[type].keys():
        seen = set()
        dups = set()

        for job in logs[type][k]:
            if job in seen:
                dups.add(job)
            else:
                seen.add(job)
                
        violation = bool(dups) or violation
        
        all_dups[k] = dups
    
    return (violation, all_dups)

def usage_exit(cmd):
    print('usage: python3 {} [-v] logname1 logname2, ...\n'
            '       -v = verbose output\n'
            '       can be invoked with * for all lognames in a directory, '
                    'e.g.\n'
            '       python3 analyselogs.py out/*'.format(cmd)
         )
    
    exit()
    
def print_separator(verbose):
    if verbose:
        print('-----------------------------------------------------------'
                '----------')
    
def print_preamble(subject, violation_type, violation_detected, verbose):
    print_separator(verbose)
    if verbose:
        print('Analysing {} {}s'.format(subject, violation_type))
        
    if violation_detected:
        prem = '*****'
        postm = ' *****'
    else:
        prem = 'OK no'
        postm = ''
    

    print('{} {} violation(s) detected for {}(s){}'.format(prem, violation_type,
        subject, postm))

def print_violations(msg, jobs, verbose, str_func = str):
    if verbose and jobs:
        print(msg)
        print(' ', '\n  '.join([str_func(j) for j in jobs]))

def process_args(args): 
    cmd = args.pop(0)
    v = False

    if '-v' in args:
        args.remove('-v')
        v = True
        
    if not args:
        usage_exit(cmd)
        
    return (v, args)

def analyse_corruptions(type, corrupted, verbose):
    print_preamble(proc_names[type], 'corruption', corruptions[0], verbose)

    for k in corrupted[1]:
        print_violations('corrupt or "null" jobs for {} {}:'.format(type, k),
            corruptions[1][k], verbose, Job.to_log)

def analyse_intersections(type, intersections, verbose):
    if not intersections[1]:
        return  # no intersections in list
        
    print_preamble(proc_names[type], 'intersection', intersections[0],
        verbose)
        
    for inter in intersections[1]:
        print_violations('jobs processed by both {} {} and {}:'.format(
            type, inter[0], inter[1]), inter[2], verbose)
    
def analyse_duplicates(type, duplicates, verbose):
    print_preamble(proc_names[type], 'duplicate', duplicates[0], verbose)

    for k in duplicates[1]:
        print_violations('duplicate jobs for {} {}:'.format(type, k),
            duplicates[1][k], verbose)
                
def analyse_differences(prod_union, cons_union, verbose):
    if prod_union and cons_union:
        inprod_notcons = prod_union.difference(cons_union)
        incons_notprod = cons_union.difference(prod_union)
    
        print_preamble('producer/consumer', 'difference', 
            inprod_notcons or incons_notprod, verbose)

        print_violations('producer jobs not consumed:', inprod_notcons, verbose)
        print_violations('consumer jobs not produced:', incons_notprod, verbose)


""" MAIN PROGRAM """
(verbose, args) = process_args(sys.argv)

logs = read_logs(args)

for type in logs:
    corruptions = get_corruptions(logs, type)
    analyse_corruptions(type, corruptions, verbose)
    intersections = get_intersections(logs, type)
    analyse_intersections(type, intersections, verbose)
    duplicates = get_duplicates(logs, type)
    analyse_duplicates(type, duplicates, verbose)
    
analyse_differences(get_union(logs, prod_t), get_union(logs, cons_t), verbose)

print_separator(verbose)